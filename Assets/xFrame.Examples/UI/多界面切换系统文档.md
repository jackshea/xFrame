# UI多界面切换系统设计文档

## 目录
- [概述](#概述)
- [核心组件](#核心组件)
- [设计原则](#设计原则)
- [使用指南](#使用指南)
- [生命周期管理](#生命周期管理)
- [最佳实践](#最佳实践)
- [完整示例](#完整示例)

---

## 概述

UI多界面切换系统（Tab System）是xFrame UI框架的扩展功能，提供了页签式的多页面管理能力。

### 核心特性

✅ **组合模式** - 使用组合模式管理父子UI的生命周期  
✅ **无感切换** - 子页面可以独立使用，也可以作为容器的一部分（对子页面无感）  
✅ **生命周期管理** - 父容器自动管理子页面的生命周期  
✅ **灵活切换** - 支持索引、类型、名称等多种方式切换页面  
✅ **事件通知** - 页面切换时触发事件通知  
✅ **Builder模式** - 提供流式API简化容器构建

### 适用场景

- 主界面的多Tab切换（首页、背包、商店、好友等）
- 设置界面的多个分类（通用、音频、视频、控制等）
- 角色界面的多个页面（属性、装备、技能等）
- 任何需要页签切换的UI场景

---

## 核心组件

### 1. UITabPage（标签页基类）

所有可切换页面的基类，继承自`UIPanel`。

```csharp
/// <summary>
/// UI标签页基类
/// 既可以独立打开使用（作为UIPanel），也可以作为UITabContainer的子页面
/// </summary>
public abstract class UITabPage : UIPanel
{
    // 是否在容器中（内部标记，子类无需关心）
    internal bool IsInContainer { get; set; }
    
    // 页面索引（在容器中的索引）
    public int PageIndex { get; internal set; }
    
    // 页面名称（用于标识）
    public virtual string PageName => GetType().Name;
    
    // 页面进入时的回调
    protected virtual void OnPageEnter() { }
    
    // 页面退出时的回调
    protected virtual void OnPageExit() { }
}
```

**特点：**
- 可以独立打开使用（作为普通UIPanel）
- 可以作为容器的子页面（TabContainer会设置IsInContainer=true）
- 对子页面来说，两种使用方式是无感知的
- 提供`OnPageEnter`和`OnPageExit`回调，用于页面切换时的逻辑

### 2. UITabContainer（标签页容器）

管理多个UITabPage的容器，负责页面切换。

```csharp
/// <summary>
/// UI标签页容器
/// 使用组合模式管理多个UITabPage，支持页面切换
/// </summary>
public class UITabContainer : UIPanel
{
    // 当前激活的页面索引
    public int CurrentPageIndex { get; private set; }
    
    // 当前激活的页面
    public UITabPage CurrentPage { get; }
    
    // 页面切换事件
    public event Action<int, int> OnPageChanged;
    
    // 添加页面
    public int AddPage<T>(T page) where T : UITabPage;
    
    // 切换页面（多种方式）
    public void SwitchPage(int index, object data = null);
    public void SwitchPage<T>(object data = null) where T : UITabPage;
    public void SwitchPage(string pageName, object data = null);
    
    // 下一页/上一页
    public void NextPage();
    public void PreviousPage();
}
```

**职责：**
- 管理所有子页面的生命周期
- 处理页面切换逻辑
- 同步父子生命周期状态
- 触发页面切换事件

### 3. UITabButton（标签按钮组件）

用于切换页面的按钮组件。

```csharp
/// <summary>
/// UI标签按钮组件
/// 用于切换UITabContainer中的页面
/// </summary>
public class UITabButton : UIComponent
{
    // 对应的页面索引
    public int PageIndex { get; private set; }
    
    // 是否选中
    public bool IsSelected { get; private set; }
    
    // 设置选中状态
    public void SetSelected(bool selected);
}
```

**特点：**
- 继承自UIComponent，可复用
- 自动处理点击事件和选中状态
- 支持自定义视觉表现

### 4. UITabContainerBuilder（构建器）

提供流式API来构建UITabContainer。

```csharp
/// <summary>
/// UI标签页容器构建器
/// </summary>
public class UITabContainerBuilder
{
    public UITabContainerBuilder WithButtonContainer(Transform container);
    public UITabContainerBuilder WithButtonPrefab(UITabButton prefab);
    public UITabContainerBuilder AddPage(UITabPage page, string text, Sprite icon);
    public UITabContainer Build();
}
```

---

## 设计原则

### 1. 组合模式

使用组合模式管理父子关系：

```
UITabContainer（容器）
  ├─ UITabPage 1（子页面）
  ├─ UITabPage 2（子页面）
  └─ UITabPage 3（子页面）
```

**原则：**
- 容器负责管理子页面的生命周期
- 容器的生命周期变化会自动传递给子页面
- 子页面不需要知道自己是否在容器中

### 2. 单向依赖

```
父容器（UITabContainer）
  ├─ 持有: 所有子页面引用
  ├─ 管理: 子页面生命周期
  └─ 控制: 页面切换逻辑

子页面（UITabPage）
  ├─ 不知道: 是否在容器中
  ├─ 不关心: 其他页面存在
  └─ 只处理: 自己的业务逻辑
```

### 3. 生命周期传递

容器的生命周期会自动传递给子页面：

| 容器生命周期 | 子页面响应 | 说明 |
|------------|----------|------|
| `OnOpen` | 激活默认页面 | 容器打开时激活第一个页面 |
| `OnShow` | 显示当前页面 | 容器显示时显示当前激活页面 |
| `OnHide` | 隐藏当前页面 | 容器隐藏时隐藏当前页面 |
| `OnClose` | 关闭所有页面 | 容器关闭时关闭所有子页面 |
| `OnDestroy` | 销毁所有页面 | 容器销毁时销毁所有子页面 |

---

## 使用指南

### 方式1：基础用法

```csharp
// 1. 创建容器
var container = Instantiate(tabContainerPrefab);

// 2. 创建页面
var homePage = Instantiate(homePagePrefab);
var inventoryPage = Instantiate(inventoryPagePrefab);
var shopPage = Instantiate(shopPagePrefab);

// 3. 添加页面到容器
container.AddPage(homePage);
container.AddPage(inventoryPage);
container.AddPage(shopPage);

// 4. 打开容器
container.InternalOnCreate();
container.InternalOnOpen(null);

// 5. 切换页面
container.SwitchPage(0);                     // 通过索引
container.SwitchPage<InventoryPage>();       // 通过类型
container.SwitchPage("ShopPage");            // 通过名称
```

### 方式2：使用Builder模式

```csharp
// 使用Builder模式构建容器
var container = Instantiate(tabContainerPrefab);

container.CreateBuilder()
    .WithButtonContainer(buttonContainer)
    .WithButtonPrefab(tabButtonPrefab)
    .AddPage(Instantiate(homePagePrefab), "首页", homeIcon)
    .AddPage(Instantiate(inventoryPagePrefab), "背包", inventoryIcon)
    .AddPage(Instantiate(shopPagePrefab), "商店", shopIcon)
    .Build();

// 打开容器
container.InternalOnCreate();
container.InternalOnOpen(null);
```

### 方式3：子页面独立使用

子页面可以脱离容器独立使用：

```csharp
// 作为容器的一部分
var container = Instantiate(tabContainerPrefab);
var pageInContainer = Instantiate(homePagePrefab);
container.AddPage(pageInContainer);
container.InternalOnCreate();
container.InternalOnOpen(null);

// 作为独立页面使用
var standalonePage = Instantiate(homePagePrefab);
standalonePage.InternalOnCreate();
standalonePage.InternalOnOpen(null);

// 对于页面来说，这两种方式是无感知的
// 页面的生命周期回调都会正常调用
```

### 创建自定义页面

```csharp
using xFrame.Runtime.UI;

/// <summary>
/// 首页
/// </summary>
public class HomePage : UITabPage
{
    public override string PageName => "首页";
    
    protected override void OnCreate()
    {
        base.OnCreate();
        // 初始化UI组件
    }
    
    protected override void OnPageEnter()
    {
        base.OnPageEnter();
        // 页面进入时的逻辑
        // 例如：刷新数据、播放动画等
        RefreshData();
    }
    
    protected override void OnPageExit()
    {
        base.OnPageExit();
        // 页面退出时的逻辑
        // 例如：保存状态、停止动画等
        SaveState();
    }
    
    protected override void OnShow()
    {
        base.OnShow();
        // 页面显示时的逻辑
    }
    
    protected override void OnHide()
    {
        base.OnHide();
        // 页面隐藏时的逻辑
    }
    
    private void RefreshData()
    {
        // 刷新数据逻辑
    }
    
    private void SaveState()
    {
        // 保存状态逻辑
    }
}
```

### 监听页面切换事件

```csharp
// 订阅页面切换事件
container.OnPageChanged += (oldIndex, newIndex) =>
{
    Debug.Log($"页面切换: {oldIndex} -> {newIndex}");
    
    // 获取新页面
    var newPage = container.GetPage(newIndex);
    Debug.Log($"切换到页面: {newPage.PageName}");
};
```

---

## 生命周期管理

### 完整生命周期流程

```
容器打开
  │
  ├─ Container.OnCreate
  │   └─ 添加所有子页面
  │
  ├─ Container.OnOpen
  │   └─ 激活默认页面（索引0）
  │       ├─ Page[0].OnCreate（如果未创建）
  │       ├─ Page[0].OnOpen
  │       ├─ Page[0].OnShow
  │       └─ Page[0].OnPageEnter
  │
  └─ Container.OnShow
      └─ CurrentPage.OnShow

切换页面（从Page1到Page2）
  │
  ├─ Page1.OnPageExit    （退出旧页面）
  ├─ Page1.OnHide        （隐藏旧页面）
  │
  ├─ Page2.OnCreate      （创建新页面，如果未创建）
  ├─ Page2.OnOpen        （打开新页面，如果未打开）
  ├─ Page2.OnShow        （显示新页面）
  └─ Page2.OnPageEnter   （进入新页面）

容器隐藏
  │
  ├─ Container.OnHide
  └─ CurrentPage.OnHide

容器关闭
  │
  ├─ Container.OnHide
  ├─ Container.OnClose
  └─ 所有子页面.OnClose

容器销毁
  │
  ├─ Container.OnDestroy
  └─ 所有子页面.OnDestroy
```

### 生命周期回调说明

| 回调 | 调用时机 | 调用次数 | 适用场景 |
|------|---------|---------|---------|
| `OnCreate` | 页面首次创建 | 1次 | 初始化UI组件、绑定事件 |
| `OnOpen` | 页面打开 | 多次 | 接收数据、重置状态 |
| `OnPageEnter` | 切换为活动页面 | 多次 | 刷新数据、播放动画 |
| `OnShow` | 页面显示 | 多次 | 恢复更新、播放音效 |
| `OnHide` | 页面隐藏 | 多次 | 停止更新、降低音量 |
| `OnPageExit` | 从活动页面切出 | 多次 | 保存状态、停止动画 |
| `OnClose` | 页面关闭 | 多次 | 清理临时数据 |
| `OnDestroy` | 页面销毁 | 1次 | 释放资源、取消订阅 |

---

## 最佳实践

### 1. 页面设计原则

#### ✅ 单一职责
每个页面只负责一个功能模块：

```csharp
// ✅ 好的设计
public class InventoryPage : UITabPage { }  // 只负责背包
public class ShopPage : UITabPage { }       // 只负责商店

// ❌ 不好的设计
public class AllInOnePage : UITabPage { }   // 什么都做
```

#### ✅ 页面独立性
页面应该是独立的，不依赖其他页面：

```csharp
// ✅ 好的设计：页面不知道其他页面
public class HomePage : UITabPage
{
    protected override void OnPageEnter()
    {
        // 自己刷新数据
        RefreshHomeData();
    }
}

// ❌ 不好的设计：页面之间相互依赖
public class HomePage : UITabPage
{
    public InventoryPage inventoryPage; // 不要引用其他页面
}
```

### 2. 生命周期使用建议

#### OnPageEnter vs OnShow
- **OnPageEnter**: 页面切换为活动状态时调用（只在Tab容器中有意义）
- **OnShow**: 页面从隐藏变为显示时调用（独立使用和容器中都会调用）

```csharp
public class MyPage : UITabPage
{
    protected override void OnPageEnter()
    {
        base.OnPageEnter();
        
        // ✅ 适合：刷新数据（页面激活时）
        RefreshData();
        
        // ✅ 适合：播放进入动画
        PlayEnterAnimation();
    }
    
    protected override void OnShow()
    {
        base.OnShow();
        
        // ✅ 适合：开始更新逻辑
        StartUpdate();
        
        // ✅ 适合：播放背景音乐
        PlayBGM();
    }
    
    protected override void OnPageExit()
    {
        base.OnPageExit();
        
        // ✅ 适合：保存状态
        SaveState();
        
        // ✅ 适合：停止动画
        StopAnimation();
    }
    
    protected override void OnHide()
    {
        base.OnHide();
        
        // ✅ 适合：停止更新逻辑
        StopUpdate();
        
        // ✅ 适合：降低音量
        ReduceVolume();
    }
}
```

### 3. 容器配置建议

```csharp
public class MainTabContainer : UITabContainer
{
    protected override void OnCreate()
    {
        base.OnCreate();
        
        // 动态创建页面
        CreatePages();
        
        // 配置页面切换事件
        OnPageChanged += HandlePageChanged;
    }
    
    private void CreatePages()
    {
        // 方式1：直接添加
        AddPage(Instantiate(homePagePrefab));
        AddPage(Instantiate(inventoryPagePrefab));
        
        // 方式2：使用Builder
        this.CreateBuilder()
            .WithButtonContainer(buttonContainer)
            .WithButtonPrefab(buttonPrefab)
            .AddPage(Instantiate(homePagePrefab), "首页")
            .AddPage(Instantiate(inventoryPagePrefab), "背包")
            .Build();
    }
    
    private void HandlePageChanged(int oldIndex, int newIndex)
    {
        // 记录页面切换
        Debug.Log($"Page changed: {oldIndex} -> {newIndex}");
        
        // 可以在这里做全局处理
        // 例如：播放切换音效
        AudioManager.PlaySound("TabSwitch");
    }
}
```

### 4. 性能优化

#### 延迟加载
对于复杂页面，可以延迟加载：

```csharp
public class HeavyPage : UITabPage
{
    private bool _dataLoaded = false;
    
    protected override void OnPageEnter()
    {
        base.OnPageEnter();
        
        // 只在第一次进入时加载数据
        if (!_dataLoaded)
        {
            LoadHeavyData();
            _dataLoaded = true;
        }
        else
        {
            RefreshLightData();
        }
    }
}
```

#### 资源释放
及时释放不需要的资源：

```csharp
public class ImageHeavyPage : UITabPage
{
    private Texture2D _heavyTexture;
    
    protected override void OnPageEnter()
    {
        base.OnPageEnter();
        // 加载资源
        LoadTexture();
    }
    
    protected override void OnPageExit()
    {
        base.OnPageExit();
        // 释放资源
        ReleaseTexture();
    }
}
```

---

## 完整示例

### 示例：主界面Tab系统

```csharp
using UnityEngine;
using xFrame.Runtime.UI;

/// <summary>
/// 主界面Tab容器
/// 包含：首页、背包、商店、好友四个页面
/// </summary>
public class MainUITabContainer : UITabContainer
{
    [Header("页面预制体")]
    [SerializeField] private HomePage homePagePrefab;
    [SerializeField] private InventoryPage inventoryPagePrefab;
    [SerializeField] private ShopPage shopPagePrefab;
    [SerializeField] private FriendPage friendPagePrefab;
    
    [Header("按钮配置")]
    [SerializeField] private Transform tabButtonContainer;
    [SerializeField] private UITabButton tabButtonPrefab;
    
    protected override void OnCreate()
    {
        base.OnCreate();
        
        // 使用Builder构建容器
        this.CreateBuilder()
            .WithButtonContainer(tabButtonContainer)
            .WithButtonPrefab(tabButtonPrefab)
            .AddPage(Instantiate(homePagePrefab), "首页")
            .AddPage(Instantiate(inventoryPagePrefab), "背包")
            .AddPage(Instantiate(shopPagePrefab), "商店")
            .AddPage(Instantiate(friendPagePrefab), "好友")
            .Build();
        
        // 监听页面切换
        OnPageChanged += OnTabPageChanged;
    }
    
    private void OnTabPageChanged(int oldIndex, int newIndex)
    {
        Debug.Log($"切换Tab页面: {oldIndex} -> {newIndex}");
        
        // 播放切换音效
        // AudioManager.PlaySound("TabSwitch");
        
        // 上报统计
        // Analytics.TrackEvent("TabSwitched", newIndex);
    }
    
    protected override void OnDestroy()
    {
        OnPageChanged -= OnTabPageChanged;
        base.OnDestroy();
    }
}

/// <summary>
/// 首页
/// </summary>
public class HomePage : UITabPage
{
    public override string PageName => "首页";
    
    protected override void OnPageEnter()
    {
        base.OnPageEnter();
        Debug.Log("[首页] 进入页面");
        
        // 刷新首页数据
        RefreshHomeData();
    }
    
    private void RefreshHomeData()
    {
        // 刷新公告、活动等
    }
}

/// <summary>
/// 背包页面
/// </summary>
public class InventoryPage : UITabPage
{
    public override string PageName => "背包";
    
    protected override void OnPageEnter()
    {
        base.OnPageEnter();
        Debug.Log("[背包] 进入页面");
        
        // 刷新背包数据
        RefreshInventory();
    }
    
    private void RefreshInventory()
    {
        // 从服务器获取背包数据
        // 更新UI显示
    }
}

/// <summary>
/// 商店页面
/// </summary>
public class ShopPage : UITabPage
{
    public override string PageName => "商店";
    
    private bool _itemsLoaded = false;
    
    protected override void OnPageEnter()
    {
        base.OnPageEnter();
        Debug.Log("[商店] 进入页面");
        
        // 延迟加载：只在第一次进入时加载商品列表
        if (!_itemsLoaded)
        {
            LoadShopItems();
            _itemsLoaded = true;
        }
        else
        {
            RefreshPrices();
        }
    }
    
    private void LoadShopItems()
    {
        // 加载商品列表（耗时操作）
    }
    
    private void RefreshPrices()
    {
        // 刷新价格（轻量操作）
    }
}

/// <summary>
/// 好友页面
/// </summary>
public class FriendPage : UITabPage
{
    public override string PageName => "好友";
    
    protected override void OnPageEnter()
    {
        base.OnPageEnter();
        Debug.Log("[好友] 进入页面");
        
        // 刷新好友列表
        RefreshFriendList();
    }
    
    private void RefreshFriendList()
    {
        // 从服务器获取好友列表
    }
}
```

---

## 总结

### 核心优势

1. **组合模式** - 清晰的父子关系，自动管理生命周期
2. **无感切换** - 子页面无需关心是否在容器中
3. **灵活切换** - 支持多种切换方式（索引、类型、名称）
4. **生命周期传递** - 父容器生命周期自动传递给子页面
5. **事件通知** - 页面切换时触发事件

### 适用场景

- ✅ 主界面多Tab切换
- ✅ 设置界面多分类
- ✅ 角色界面多页面
- ✅ 任何需要页签切换的场景

### 注意事项

1. **始终调用base** - 重写生命周期方法时必须调用base
2. **页面独立性** - 页面之间不要相互引用
3. **资源管理** - 及时释放不需要的资源
4. **生命周期理解** - 理解OnPageEnter/OnPageExit和OnShow/OnHide的区别

---

## 相关文档

- `UI框架.md` - UI框架整体设计
- `UI组件复用设计.md` - 组件复用系统
- `TabSystemExample.cs` - 完整示例代码
