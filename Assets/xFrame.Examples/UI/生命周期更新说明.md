# UI框架生命周期更新说明

## 更新内容

在UI框架中新增了 **OnShow** 和 **OnHide** 生命周期回调，使UI的状态管理更加精细。

---

## 完整生命周期

### 生命周期流程图

```
创建 ──→ 打开 ──→ 显示 ──→ 隐藏 ──→ 显示 ──→ ... ──→ 隐藏 ──→ 关闭 ──→ 销毁
  │       │       │       │       │               │       │       │
OnCreate OnOpen OnShow OnHide OnShow          OnHide OnClose OnDestroy
  │       │       │       │       │               │       │       │
 (1次)   (多次)  (多次)  (多次)  (多次)          (多次)  (多次)   (1次)
```

### 调用场景

| 生命周期 | 调用时机 | 调用次数 | 典型用途 |
|---------|---------|---------|---------|
| **OnCreate** | UI实例首次创建 | 1次 | 绑定事件、获取组件引用 |
| **OnOpen** | UI打开 | 多次 | 接收数据、初始化状态 |
| **OnShow** | UI显示（打开后、从栈恢复） | 多次 | 播放动画、恢复更新、刷新数据 |
| **OnHide** | UI隐藏（被遮挡、关闭前） | 多次 | 暂停动画、停止更新、保存状态 |
| **OnClose** | UI关闭 | 多次 | 清理临时数据 |
| **OnDestroy** | UI实例销毁 | 1次 | 取消事件订阅、释放资源 |

---

## 典型使用场景

### 场景1: 首次打开UI

```
OnCreate → OnOpen → OnShow
```

**说明**: 
- OnCreate: 创建UI实例，绑定按钮事件
- OnOpen: 接收传入的数据
- OnShow: 播放显示动画，开始更新逻辑

### 场景2: UI被其他UI遮挡

```
当前UI: OnHide
新UI: OnCreate → OnOpen → OnShow
```

**说明**:
- 当前UI执行OnHide，暂停动画和更新
- 新UI正常打开流程

### 场景3: 从导航栈恢复

```
当前UI: OnHide → OnClose
前一个UI: OnShow
```

**说明**:
- 当前UI先隐藏再关闭
- 前一个UI从栈中恢复，重新显示

### 场景4: 关闭UI

```
OnHide → OnClose → OnDestroy (如果不缓存)
```

**说明**:
- 先隐藏UI（停止所有活动）
- 再关闭UI（清理数据）
- 如果不缓存，最后销毁实例

---

## 代码示例

### 基础示例

```csharp
public class GamePanel : UIPanel
{
    private bool _isUpdateActive;
    
    protected override void OnCreate()
    {
        // 只执行一次的初始化
        Debug.Log("创建UI");
    }
    
    protected override void OnOpen(object data)
    {
        // 每次打开时执行
        Debug.Log("打开UI");
    }
    
    protected override void OnShow()
    {
        // 显示时执行（打开后、恢复时）
        Debug.Log("显示UI");
        _isUpdateActive = true;
    }
    
    protected override void OnHide()
    {
        // 隐藏时执行（遮挡时、关闭前）
        Debug.Log("隐藏UI");
        _isUpdateActive = false;
    }
    
    protected override void OnClose()
    {
        // 关闭时执行
        Debug.Log("关闭UI");
    }
    
    protected override void OnDestroy()
    {
        // 销毁时执行
        Debug.Log("销毁UI");
    }
    
    private void Update()
    {
        // 只在显示时更新
        if (!_isUpdateActive) return;
        
        // 游戏逻辑
    }
}
```

### 带动画和音效的示例

```csharp
public class BattlePanel : UIPanel
{
    private bool _isUpdateActive;
    private Animator _animator;
    
    protected override void OnShow()
    {
        base.OnShow();
        
        // 1. 播放显示动画
        _animator.SetTrigger("Show");
        
        // 2. 播放BGM
        AudioManager.Instance.PlayBGM("BattleMusic");
        AudioManager.Instance.SetVolume(1.0f);
        
        // 3. 开始战斗更新
        _isUpdateActive = true;
        
        // 4. 刷新UI（可能在被遮挡期间数据已更新）
        RefreshBattleInfo();
        
        Debug.Log("战斗界面显示");
    }
    
    protected override void OnHide()
    {
        base.OnHide();
        
        // 1. 播放隐藏动画
        _animator.SetTrigger("Hide");
        
        // 2. 降低BGM音量
        AudioManager.Instance.SetVolume(0.3f);
        
        // 3. 停止战斗更新，节省性能
        _isUpdateActive = false;
        
        // 4. 保存战斗状态（如果需要）
        SaveBattleState();
        
        Debug.Log("战斗界面隐藏");
    }
    
    private void Update()
    {
        if (!_isUpdateActive) return;
        
        // 战斗逻辑只在显示时更新
        UpdateBattle();
    }
}
```

### 导航栈示例

```csharp
// 场景：A → B → C，然后Back返回

// 打开A
await uiManager.OpenAsync<PanelA>();
// 执行: OnCreate → OnOpen → OnShow

// 打开B (A被压入栈)
await uiManager.OpenAsync<PanelB>();
// A执行: OnHide
// B执行: OnCreate → OnOpen → OnShow

// 打开C (B被压入栈)
await uiManager.OpenAsync<PanelC>();
// B执行: OnHide
// C执行: OnCreate → OnOpen → OnShow

// Back返回到B
uiManager.Back();
// C执行: OnHide → OnClose
// B执行: OnShow (从栈恢复)

// Back返回到A
uiManager.Back();
// B执行: OnHide → OnClose
// A执行: OnShow (从栈恢复)
```

---

## 最佳实践

### ✅ 推荐做法

1. **在OnShow中启动活动**
   ```csharp
   protected override void OnShow()
   {
       // 开始更新逻辑
       _isUpdateActive = true;
       
       // 播放动画
       PlayShowAnimation();
       
       // 刷新数据
       RefreshData();
   }
   ```

2. **在OnHide中停止活动**
   ```csharp
   protected override void OnHide()
   {
       // 停止更新逻辑
       _isUpdateActive = false;
       
       // 暂停动画
       PauseAnimations();
       
       // 降低音量
       ReduceVolume();
   }
   ```

3. **使用标志位控制Update**
   ```csharp
   private bool _isUpdateActive;
   
   private void Update()
   {
       if (!_isUpdateActive) return;
       // 只在显示时更新
   }
   ```

### ❌ 避免的做法

1. **不要在OnHide中销毁资源**
   ```csharp
   // ❌ 错误：OnHide不是销毁，UI可能还会再显示
   protected override void OnHide()
   {
       Destroy(_importantObject); // 不要这样做！
   }
   
   // ✅ 正确：在OnDestroy中销毁
   protected override void OnDestroy()
   {
       Destroy(_importantObject);
   }
   ```

2. **不要在OnShow中做耗时操作**
   ```csharp
   // ❌ 错误：OnShow会被频繁调用，不应该有耗时操作
   protected override void OnShow()
   {
       LoadHeavyResources(); // 应该在OnOpen或OnCreate中
   }
   
   // ✅ 正确：耗时操作在OnCreate或OnOpen中
   protected override void OnCreate()
   {
       LoadHeavyResources();
   }
   ```

---

## 性能优化建议

1. **利用OnHide停止更新，节省CPU**
   - 被遮挡的UI不需要每帧更新
   - 可以大幅提升性能

2. **利用OnShow刷新数据**
   - 在显示时检查数据是否过期
   - 只在需要时刷新

3. **合理使用动画**
   - OnShow时播放显示动画
   - OnHide时可以跳过隐藏动画（快速响应）

---

## 迁移指南

如果你有旧的UI代码，可以这样迁移：

### 旧代码
```csharp
protected override void OnOpen(object data)
{
    // 显示UI
    gameObject.SetActive(true);
    
    // 播放动画
    PlayAnimation();
    
    // 开始更新
    _isActive = true;
}

protected override void OnClose()
{
    // 停止更新
    _isActive = false;
    
    // 隐藏UI
    gameObject.SetActive(false);
}
```

### 新代码
```csharp
protected override void OnOpen(object data)
{
    // 只处理数据接收
    // SetActive和动画由框架在OnShow中自动处理
}

protected override void OnShow()
{
    // 播放动画
    PlayAnimation();
    
    // 开始更新
    _isActive = true;
}

protected override void OnHide()
{
    // 停止更新
    _isActive = false;
    
    // 暂停动画
    PauseAnimation();
}

protected override void OnClose()
{
    // 清理数据
}
```

---

## 总结

新增的OnShow/OnHide生命周期让UI管理更加精细：

- **OnShow**: UI真正可见时调用，适合启动动画和更新
- **OnHide**: UI被遮挡或即将关闭时调用，适合暂停活动和保存状态

这样的设计能够：
1. ✅ 提升性能（隐藏的UI不更新）
2. ✅ 更好的用户体验（恢复时刷新数据）
3. ✅ 更清晰的代码结构（职责分离）

查看完整示例请参考：`UINavigationStackExample.cs`
