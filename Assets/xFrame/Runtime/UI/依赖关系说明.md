# UI组件系统依赖关系说明

## 依赖方向

**父组件知道子组件，子组件不知道父组件**

```
父组件 (UIView)
  │
  ├─ 持有 ──────> 子组件引用列表
  ├─ 管理 ──────> ComponentManager
  ├─ 订阅 ──────> 事件总线
  └─ 可以 ──────> 直接调用子组件方法

子组件 (UIComponent)
  │
  ├─ 不持有 ────X 父组件引用
  ├─ 发送 ──────> 全局事件（通过事件总线）
  └─ 不知道 ────X 谁在监听事件
```

---

## 为什么这样设计？

### 1. 符合组合模式（Composite Pattern）

在传统的设计模式中，组合模式的父节点持有子节点引用，子节点不持有父节点引用。这是经典的组合关系。

```csharp
// 经典组合模式
public class Container
{
    private List<Component> _components;  // 父持有子
    
    public void AddComponent(Component component)
    {
        _components.Add(component);
    }
}

public class Component
{
    // 不持有Container引用
}
```

### 2. 降低耦合度

**子组件不知道父组件** 意味着：
- ✅ 子组件可以在任何父组件中复用
- ✅ 子组件不依赖特定的父组件类型
- ✅ 子组件更加独立和纯粹

```csharp
// ✅ ItemSlotComponent可以在多个父UI中复用
public class InventoryPanel : UIPanel { ... }
public class WarehousePanel : UIPanel { ... }
public class ShopPanel : UIPanel { ... }

// 它们都可以使用同一个ItemSlotComponent
// 因为ItemSlotComponent不知道也不关心父组件是谁
```

### 3. 控制权在父组件

父组件作为容器和管理者，应该：
- ✅ 控制子组件的创建和销毁
- ✅ 管理子组件的生命周期
- ✅ 协调多个子组件之间的交互

```csharp
public class InventoryPanel : UIPanel
{
    // 父组件决定创建多少个子组件
    // 父组件决定如何布局子组件
    // 父组件决定子组件如何交互
    
    private List<ItemSlotComponent> _slots;
    
    public void SwapItems(int index1, int index2)
    {
        var data1 = _slots[index1].GetData();
        var data2 = _slots[index2].GetData();
        _slots[index1].SetData(data2);
        _slots[index2].SetData(data1);
    }
}
```

### 4. 单向数据流

数据流方向清晰：
- **父 → 子**: 直接调用方法传递数据
- **子 → 父**: 通过事件通知状态变化

```csharp
// 父 → 子：直接调用
slot.SetData(itemData);
slot.Show();
slot.SetSelected(true);

// 子 → 父：事件通知
SendEvent(new ItemClickedEvent { ... });
```

---

## 通讯机制

### 子组件 → 父组件（事件总线）

子组件通过事件总线发送**全局事件**，不需要知道谁在监听。

**优点：**
- ✅ 完全解耦
- ✅ 可以有多个监听者
- ✅ 子组件不依赖父组件类型

```csharp
// 子组件发送
public class ItemSlotComponent : UIComponent
{
    private void OnClicked()
    {
        // 发送全局事件，不知道谁在监听
        SendEvent(new ItemClickedEvent { ItemId = 123 });
    }
}

// 父组件接收
public class InventoryPanel : UIPanel
{
    protected override void OnCreate()
    {
        xFrameEventBus.SubscribeTo<UIComponentEventWrapper<ItemClickedEvent>>(
            OnItemClicked);
    }
    
    private void OnItemClicked(ref UIComponentEventWrapper<ItemClickedEvent> evt)
    {
        // 通过ComponentId识别是哪个子组件
        var slot = ComponentManager.GetComponent<ItemSlotComponent>(evt.ComponentId);
    }
}
```

### 父组件 → 子组件（直接调用）

父组件持有子组件引用，可以直接调用公开方法。

**优点：**
- ✅ 简单直接
- ✅ 类型安全
- ✅ 性能更好（无需事件）

```csharp
public class InventoryPanel : UIPanel
{
    private List<ItemSlotComponent> _slots;
    
    // 直接调用子组件方法
    public void SelectSlot(int index)
    {
        _slots[index].SetSelected(true);
    }
    
    public void LoadItems(List<ItemData> items)
    {
        for (int i = 0; i < items.Count && i < _slots.Count; i++)
        {
            _slots[i].SetData(items[i]);
            _slots[i].Show();
        }
    }
}
```

---

## 对比其他设计

### ❌ 反向设计（子组件知道父组件）

```csharp
// 不推荐的设计
public class ItemSlotComponent : UIComponent
{
    public InventoryPanel ParentPanel { get; set; }  // 依赖具体父组件
    
    private void OnClicked()
    {
        ParentPanel.HandleSlotClick(this);  // 直接调用父组件
    }
}
```

**问题：**
- ❌ 子组件依赖具体的父组件类型
- ❌ 子组件不能在其他父组件中复用
- ❌ 高耦合，难以维护
- ❌ 如果子组件要在WarehousePanel中使用，怎么办？

### ✅ 当前设计（父组件知道子组件）

```csharp
// 推荐的设计
public class ItemSlotComponent : UIComponent
{
    // 不持有父组件引用
    
    private void OnClicked()
    {
        SendEvent(new ItemClickedEvent { ... });  // 发送全局事件
    }
}

public class InventoryPanel : UIPanel
{
    private List<ItemSlotComponent> _slots;  // 持有子组件引用
}

public class WarehousePanel : UIPanel
{
    private List<ItemSlotComponent> _slots;  // 同样可以使用
}
```

**优点：**
- ✅ 子组件完全独立，可以在任何地方复用
- ✅ 低耦合，易于维护
- ✅ 父组件拥有控制权
- ✅ 数据流向清晰

---

## 实际应用场景

### 场景1：背包和仓库共用ItemSlot

```csharp
// ItemSlotComponent - 通用组件，不知道父组件
public class ItemSlotComponent : UIComponent
{
    private void OnClicked()
    {
        SendEvent(new ItemSlotClickedEvent { ... });
    }
}

// InventoryPanel - 背包
public class InventoryPanel : UIPanel
{
    private List<ItemSlotComponent> _slots;
    
    private void OnItemSlotClicked(ref UIComponentEventWrapper<ItemSlotClickedEvent> evt)
    {
        // 背包的处理逻辑
        HandleInventorySlotClick(evt);
    }
}

// WarehousePanel - 仓库
public class WarehousePanel : UIPanel
{
    private List<ItemSlotComponent> _slots;
    
    private void OnItemSlotClicked(ref UIComponentEventWrapper<ItemSlotClickedEvent> evt)
    {
        // 仓库的处理逻辑（可能和背包不同）
        HandleWarehouseSlotClick(evt);
    }
}
```

### 场景2：父组件协调多个子组件

```csharp
public class InventoryPanel : UIPanel
{
    private List<ItemSlotComponent> _slots;
    private ItemSlotComponent _selectedSlot;
    
    private void OnItemSlotClicked(ref UIComponentEventWrapper<ItemSlotClickedEvent> evt)
    {
        var clickedSlot = evt.SourceComponent as ItemSlotComponent;
        
        if (_selectedSlot != null)
        {
            // 清除之前选中的槽位
            _selectedSlot.SetSelected(false);
            
            // 交换物品
            SwapItems(_selectedSlot, clickedSlot);
            _selectedSlot = null;
        }
        else
        {
            // 选中新槽位
            clickedSlot.SetSelected(true);
            _selectedSlot = clickedSlot;
        }
    }
    
    private void SwapItems(ItemSlotComponent slot1, ItemSlotComponent slot2)
    {
        var data1 = slot1.GetData();
        var data2 = slot2.GetData();
        slot1.SetData(data2);
        slot2.SetData(data1);
    }
}
```

---

## 总结

### 核心原则

1. **父组件知道子组件** - 持有引用，拥有控制权
2. **子组件不知道父组件** - 保持独立，提高复用性
3. **事件向上** - 子组件通过事件通知父组件
4. **调用向下** - 父组件直接调用子组件方法

### 关键优势

- ✅ **低耦合** - 子组件不依赖父组件类型
- ✅ **高复用** - 子组件可以在任何父组件中使用
- ✅ **易维护** - 职责清晰，数据流向明确
- ✅ **符合设计模式** - 遵循组合模式原则

### 适用场景

- ✅ 需要复用的UI组件（物品槽、技能按钮、聊天气泡等）
- ✅ 父组件需要协调多个子组件的交互
- ✅ 同一个组件需要在不同父组件中使用
- ✅ 希望保持子组件的独立性和纯粹性

---

这种设计让组件系统更加健壮和灵活！
