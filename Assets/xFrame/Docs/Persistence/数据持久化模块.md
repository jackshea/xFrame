# xFrame 数据持久化模块使用文档

## 1. 概述

数据持久化模块提供了一套完整的数据存储解决方案，支持：
- **多种存储介质**：本地文件、内存存储、加密文件
- **数据安全**：AES加密、SHA256/CRC32校验
- **版本迁移**：自动处理数据结构升级
- **异步操作**：基于UniTask的异步API
- **VContainer集成**：便捷的依赖注入支持

## 2. 快速开始

### 2.1 基础使用

```csharp
using xFrame.Runtime.Persistence;
using xFrame.Runtime.Persistence.Storage;
using xFrame.Runtime.Serialization;
using UnityEngine;

// 定义数据类
[Serializable]
public class PlayerData
{
    public string playerName;
    public int level;
    public float experience;
}

// 创建持久化管理器
var serializer = new JsonSerializer();
var config = PersistenceConfig.CreateDefault(Application.persistentDataPath);
var provider = new FilePersistenceProvider(serializer, config.BasePath);
var manager = new PersistenceManager(provider, serializer, config);

// 保存数据
var playerData = new PlayerData { playerName = "Hero", level = 10, experience = 1500f };
manager.Save(playerData);

// 加载数据
var loadedData = manager.Load<PlayerData>();
Debug.Log($"玩家: {loadedData.playerName}, 等级: {loadedData.level}");

// 使用自定义键
manager.Save("player_slot_1", playerData);
var slot1Data = manager.Load<PlayerData>("player_slot_1");

// 检查数据是否存在
if (manager.Exists<PlayerData>())
{
    // 数据存在
}

// 删除数据
manager.Delete<PlayerData>();
```

### 2.2 使用VContainer注册

```csharp
using VContainer;
using xFrame.Runtime.Persistence;
using xFrame.Runtime.Serialization;

public class GameLifetimeScope : LifetimeScope
{
    protected override void Configure(IContainerBuilder builder)
    {
        // 注册序列化模块（持久化模块依赖）
        builder.RegisterSerializationModule();
        
        // 注册持久化模块（使用默认配置）
        builder.RegisterPersistenceModule();
        
        // 或者使用自定义配置
        var config = new PersistenceConfig
        {
            BasePath = Application.persistentDataPath + "/SaveData",
            FileExtension = ".save",
            EnableValidation = true,
            ValidatorType = ValidatorType.Sha256
        };
        builder.RegisterPersistenceModule(config);
    }
}

// 在其他类中注入使用
public class GameManager
{
    private readonly IPersistenceManager _persistence;
    
    public GameManager(IPersistenceManager persistence)
    {
        _persistence = persistence;
    }
    
    public void SaveGame()
    {
        var saveData = new GameSaveData { /* ... */ };
        _persistence.Save(saveData);
    }
}
```

## 3. 异步操作

所有持久化操作都支持异步版本，避免阻塞主线程：

```csharp
using Cysharp.Threading.Tasks;

public class AsyncSaveManager
{
    private readonly IPersistenceManager _persistence;
    
    public async UniTask SaveGameAsync()
    {
        var saveData = new GameSaveData { /* ... */ };
        await _persistence.SaveAsync(saveData);
        Debug.Log("保存完成");
    }
    
    public async UniTask<GameSaveData> LoadGameAsync()
    {
        var data = await _persistence.LoadAsync<GameSaveData>();
        return data;
    }
    
    public async UniTask<GameSaveData> LoadOrCreateAsync()
    {
        var defaultData = new GameSaveData { level = 1 };
        return await _persistence.LoadOrDefaultAsync(defaultData);
    }
}
```

## 4. 数据加密

### 4.1 使用AES加密

```csharp
using xFrame.Runtime.Persistence.Security;

// 方式1：使用密码字符串
var encryptor = new AesEncryptor("your_secret_password");

// 方式2：使用密码和盐值
var encryptor = new AesEncryptor("password", "custom_salt");

// 方式3：使用原始密钥和IV
byte[] key = new byte[32]; // 32字节密钥
byte[] iv = new byte[16];  // 16字节IV
var encryptor = new AesEncryptor(key, iv);

// 创建加密的持久化管理器
var provider = new FilePersistenceProvider(serializer, basePath);
var manager = new PersistenceManager(provider, serializer, config, encryptor);
```

### 4.2 使用VContainer注册安全持久化

```csharp
// 注册启用加密的持久化模块
builder.RegisterSecurePersistenceModule("your_encryption_key");

// 或者使用完整配置
var config = PersistenceConfig.CreateSecure(
    Application.persistentDataPath,
    "your_encryption_key"
);
builder.RegisterPersistenceModule(config);
```

## 5. 数据校验

### 5.1 可用的校验器

| 校验器 | 说明 | 适用场景 |
|--------|------|----------|
| `NoValidator` | 不校验 | 开发测试 |
| `Crc32Validator` | CRC32校验 | 快速校验，安全性要求低 |
| `Sha256Validator` | SHA256校验 | 高安全性要求 |

### 5.2 配置校验器

```csharp
var config = new PersistenceConfig
{
    EnableValidation = true,
    ValidatorType = ValidatorType.Sha256
};

// 或者手动指定校验器
var validator = new Sha256Validator();
var manager = new PersistenceManager(provider, serializer, config, null, validator);
```

## 6. 数据版本迁移

### 6.1 定义版本化数据

```csharp
// 版本1的数据结构
[Serializable]
public class UserDataV1 : IVersionedData
{
    public int CurrentVersion => 1;
    public string name;
    public int age;
}

// 版本2的数据结构（添加了email字段）
[Serializable]
public class UserDataV2 : IVersionedData
{
    public int CurrentVersion => 2;
    public string name;
    public int age;
    public string email;
}
```

### 6.2 创建迁移器

```csharp
using xFrame.Runtime.Persistence.Migration;

// 方式1：使用泛型迁移器基类
public class UserDataMigratorV1ToV2 : DataMigratorBase<UserDataV1, UserDataV2>
{
    public override int FromVersion => 1;
    public override int ToVersion => 2;
    
    public override UserDataV2 MigrateTyped(UserDataV1 oldData)
    {
        return new UserDataV2
        {
            name = oldData.name,
            age = oldData.age,
            email = "unknown@example.com" // 设置默认值
        };
    }
}

// 方式2：使用JSON字符串迁移器
public class CustomMigrator : DataMigratorBase
{
    public override int FromVersion => 1;
    public override int ToVersion => 2;
    
    public override string Migrate(string oldJson)
    {
        // 直接操作JSON字符串
        return oldJson.Replace("}", ",\"newField\":\"default\"}");
    }
}
```

### 6.3 注册迁移器

```csharp
// 注册迁移器
_persistence.RegisterMigrator<UserDataV2>(new UserDataMigratorV1ToV2());

// 加载数据时会自动执行迁移
var userData = _persistence.Load<UserDataV2>();
```

### 6.4 链式迁移

如果数据版本跨越多个版本，系统会自动链式执行迁移：

```csharp
// 注册多个迁移器
_persistence.RegisterMigrator<UserDataV3>(new UserDataMigratorV1ToV2());
_persistence.RegisterMigrator<UserDataV3>(new UserDataMigratorV2ToV3());

// 从V1加载时，会自动执行 V1 -> V2 -> V3 的迁移链
var userData = _persistence.Load<UserDataV3>();
```

## 7. 存储提供者

### 7.1 文件存储（FilePersistenceProvider）

```csharp
var provider = new FilePersistenceProvider(
    serializer,
    Application.persistentDataPath + "/SaveData",
    ".save"  // 文件扩展名
);

// 获取所有存储的键
string[] keys = provider.GetAllKeys();

// 清除所有数据
provider.Clear();
```

### 7.2 内存存储（MemoryPersistenceProvider）

适用于测试或临时缓存：

```csharp
var provider = new MemoryPersistenceProvider(serializer);

// 获取存储数量
int count = provider.Count;

// 获取所有键
var keys = provider.GetAllKeys();

// 清除所有数据
provider.Clear();
```

### 7.3 加密文件存储（EncryptedFilePersistenceProvider）

```csharp
var encryptor = new AesEncryptor("password");
var provider = new EncryptedFilePersistenceProvider(
    serializer,
    basePath,
    encryptor,
    ".enc"  // 加密文件扩展名
);
```

## 8. 配置选项

### 8.1 PersistenceConfig 完整配置

```csharp
var config = new PersistenceConfig
{
    // 基础路径
    BasePath = Application.persistentDataPath,
    
    // 文件扩展名
    FileExtension = ".dat",
    
    // 加密设置
    EnableEncryption = true,
    EncryptionKey = "your_secret_key",
    EncryptionSalt = "optional_salt",
    
    // 校验设置
    EnableValidation = true,
    ValidatorType = ValidatorType.Sha256,
    
    // 版本管理
    EnableVersioning = true,
    
    // 备份设置
    EnableBackup = true,
    MaxBackupCount = 3,
    
    // 异步设置
    UseAsync = true,
    
    // 缓存设置
    EnableCache = false,
    CacheExpirationSeconds = 300
};
```

### 8.2 预设配置

```csharp
// 默认配置
var defaultConfig = PersistenceConfig.CreateDefault(basePath);

// 安全配置（启用加密和校验）
var secureConfig = PersistenceConfig.CreateSecure(basePath, "encryption_key");
```

## 9. 自定义扩展

### 9.1 自定义存储提供者

```csharp
public class CloudPersistenceProvider : PersistenceProviderBase
{
    public override string Name => "Cloud";
    
    public CloudPersistenceProvider(ISerializer serializer) : base(serializer) { }
    
    public override bool Exists(string key)
    {
        // 实现云端检查逻辑
    }
    
    public override bool Delete(string key)
    {
        // 实现云端删除逻辑
    }
    
    public override void SaveRaw(string key, byte[] data)
    {
        // 实现云端保存逻辑
    }
    
    public override UniTask SaveRawAsync(string key, byte[] data)
    {
        // 实现异步云端保存逻辑
    }
    
    public override byte[] LoadRaw(string key)
    {
        // 实现云端加载逻辑
    }
    
    public override UniTask<byte[]> LoadRawAsync(string key)
    {
        // 实现异步云端加载逻辑
    }
}
```

### 9.2 自定义加密器

```csharp
public class XorEncryptor : IEncryptor
{
    private readonly byte _key;
    
    public string Name => "XOR";
    
    public XorEncryptor(byte key)
    {
        _key = key;
    }
    
    public byte[] Encrypt(byte[] plainData)
    {
        var result = new byte[plainData.Length];
        for (int i = 0; i < plainData.Length; i++)
        {
            result[i] = (byte)(plainData[i] ^ _key);
        }
        return result;
    }
    
    public byte[] Decrypt(byte[] cipherData)
    {
        return Encrypt(cipherData); // XOR是对称的
    }
}
```

### 9.3 自定义校验器

```csharp
public class Md5Validator : IValidator
{
    public string Name => "MD5";
    
    public byte[] ComputeHash(byte[] data)
    {
        using var md5 = System.Security.Cryptography.MD5.Create();
        return md5.ComputeHash(data);
    }
    
    public bool VerifyHash(byte[] data, byte[] hash)
    {
        var computed = ComputeHash(data);
        return computed.SequenceEqual(hash);
    }
}
```

## 10. 最佳实践

### 10.1 数据类设计

```csharp
// 推荐：使用[Serializable]标记
[Serializable]
public class GameSaveData
{
    // 使用公共字段（JsonUtility要求）
    public string playerName;
    public int level;
    public float[] stats;
    
    // 嵌套类型也需要[Serializable]
    public InventoryData inventory;
}

[Serializable]
public class InventoryData
{
    public ItemData[] items;
}
```

### 10.2 错误处理

```csharp
try
{
    var data = _persistence.Load<GameSaveData>();
    if (data == null)
    {
        // 数据不存在，使用默认值
        data = new GameSaveData();
    }
}
catch (DataValidationException ex)
{
    // 数据校验失败，可能被篡改
    Debug.LogError($"数据校验失败: {ex.Key}");
}
catch (EncryptionException ex)
{
    // 加密/解密失败
    Debug.LogError($"加密操作失败: {ex.Message}");
}
catch (DataMigrationException ex)
{
    // 数据迁移失败
    Debug.LogError($"迁移失败: {ex.DataType.Name} v{ex.FromVersion} -> v{ex.ToVersion}");
}
```

### 10.3 性能优化

```csharp
// 1. 使用异步操作避免阻塞
await _persistence.SaveAsync(data);

// 2. 批量保存时考虑合并
var combinedData = new CombinedSaveData
{
    player = playerData,
    settings = settingsData,
    progress = progressData
};
_persistence.Save(combinedData);

// 3. 对于频繁访问的数据，考虑使用内存缓存
var cachedData = _persistence.LoadOrDefault(defaultData);
// 在内存中修改，定期保存
```

## 11. 模块结构

```
xFrame.Runtime.Persistence/
├── IPersistenceProvider.cs      # 持久化提供者接口
├── IPersistenceManager.cs       # 持久化管理器接口
├── PersistenceManager.cs        # 持久化管理器实现
├── PersistenceConfig.cs         # 配置类
├── PersistenceException.cs      # 异常类
├── PersistenceServiceExtensions.cs  # VContainer扩展
├── DataWrapper.cs               # 数据包装结构
├── IVersionedData.cs            # 版本化数据接口
├── Security/                    # 安全层
│   ├── IEncryptor.cs           # 加密器接口
│   ├── IValidator.cs           # 校验器接口
│   ├── NoEncryptor.cs          # 无加密实现
│   ├── AesEncryptor.cs         # AES加密实现
│   ├── NoValidator.cs          # 无校验实现
│   ├── Sha256Validator.cs      # SHA256校验实现
│   └── Crc32Validator.cs       # CRC32校验实现
├── Storage/                     # 存储层
│   ├── PersistenceProviderBase.cs      # 提供者基类
│   ├── FilePersistenceProvider.cs      # 文件存储
│   ├── MemoryPersistenceProvider.cs    # 内存存储
│   └── EncryptedFilePersistenceProvider.cs  # 加密文件存储
└── Migration/                   # 迁移层
    ├── IDataMigrator.cs        # 迁移器接口
    ├── DataMigratorBase.cs     # 迁移器基类
    └── MigrationManager.cs     # 迁移管理器
```

## 12. 单元测试

测试文件位于 `Assets/xFrame/Tests/EditMode/PersistenceTests/`：

- `SecurityTests.cs` - 加密器和校验器测试
- `StorageTests.cs` - 存储提供者测试
- `MigrationTests.cs` - 数据迁移测试
- `PersistenceManagerTests.cs` - 持久化管理器测试

运行测试：
1. 打开 Unity Test Runner (Window > General > Test Runner)
2. 选择 EditMode 标签
3. 运行 PersistenceTests 下的所有测试
