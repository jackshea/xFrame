# Unity 数据持久化模块设计文档

## 1 设计目标

### 跨平台兼容
- 支持 **PC / Mac / iOS / Android** 等主流平台。
- 避免使用反射动态生成类（如 `System.Reflection.Emit`、`dynamic`），确保 **AOT 环境**（如 iOS IL2CPP）能稳定运行。

### 弱依赖 Unity 引擎
- 核心框架避免直接继承 `MonoBehaviour` 或调用 Unity 特有 API（如 `PlayerPrefs`）。
- 可以直接抽离到纯 .NET 环境或其他游戏引擎使用。

### 可扩展性
- 支持多种 **序列化方式**（Json、Binary、自定义格式）。
- 支持多种 **存储介质**（本地文件、内存存储、加密文件）。
- 提供统一接口，便于替换具体实现。

### 易用性
- 高层 API 尽可能简化：业务只需指定数据类型即可保存、读取数据。
- 默认 Key 自动生成，减少开发人员手动维护。

### 数据安全
- 支持 **加密存储**（如 AES 或自定义算法）。
- 提供 **数据校验**（hash 或签名）防止数据损坏或篡改。
- 异常恢复策略（加载失败时使用默认值）。

### 数据版本迁移
- 内置版本字段 `dataVersion`。
- 支持数据结构升级（旧结构→新结构）方式，模块自动管理迁移过程。

---

## 2. 模块整体结构

```
+------------------------------------------------------+
|                    持久化管理器 PersistenceManager   |
+-----------------------------+------------------------+
|      序列化层 Serialization |    存储介质层 Storage  |
+-----------------------------+------------------------+
| IDataSerializer             | IPersistenceProvider  |
| (Json/Binary/Custom)        | (File/Memory/Cloud)   |
+-----------------------------+------------------------+
| 数据迁移层 Migration        | 数据安全层 Security    |
+-----------------------------+------------------------+
| IDataMigrator                | IEncryptor / IValidator|
+------------------------------------------------------+
```

---

## 3. 核心模块设计

### 3.1 IPersistenceProvider（统一持久化抽象）
```csharp
public interface IPersistenceProvider
{
    void Save<T>(string key, T data);
    T Load<T>(string key);
    bool Exists(string key);
    void Delete(string key);
}
```
- **Key** 可选，如果未指定则通过 `T` 自动生成（如 `typeof(T).FullName`）。
- 屏蔽存储介质细节（本地文件/内存/云端等）。

#### 典型实现示例
- `FilePersistenceProvider`（保存到文件系统）
- `MemoryPersistenceProvider`（用于测试或缓存）
- `EncryptedFilePersistenceProvider`（文件存储 + 加密）

---

### 3.2 序列化层

#### 接口定义
- `IDataSerializer`
    - `byte[] Serialize<T>(T obj)`
    - `T Deserialize<T>(byte[] data)`

#### 实现策略
- `JsonSerializer`（UTF-8 JSON，可读性高，便于调试）
- `BinarySerializer`（二进制，体积更小）
- `CustomSerializer`（针对特定游戏数据优化）

> **AOT 注意事项**：
> - 避免使用 `System.Reflection.Emit`
> - 使用代码生成或手动注册序列化模型（可兼容 Unity AOT 限制）

---

### 3.3 数据安全层

- **加密接口**：`IEncryptor`
    - `byte[] Encrypt(byte[] plainData)`
    - `byte[] Decrypt(byte[] cipherData)`
    - 默认提供 `NoEncryptor`（无加密） 和 `AesEncryptor`

- **校验接口**：`IValidator`
    - `byte[] ComputeHash(byte[] data)`
    - `bool VerifyHash(byte[] data, byte[] hash)`
    - 默认提供 CRC32 / SHA256 实现

---

### 3.4 数据版本与迁移

#### 数据包装结构 `DataWrapper`
- `int dataVersion`
- `byte[] rawPayload`
- 可选 `hash`/`signature` 字段

#### 迁移流程
1. 加载原始存储数据 → 反序列化为 `DataWrapper`
2. 检查 `dataVersion` 与当前版本
3. 如果旧版本 < 目标版本：
    - 顺序执行 **版本迁移器**（`IDataMigrator<T>`）
4. 迁移完毕后获得最新版本数据类型实例
5. 将最新数据版本重新存储

#### 迁移器接口
- `IDataMigrator<T>`
    - `int FromVersion { get; }`
    - `int ToVersion { get; }`
    - `T Migrate(object oldData)`

#### 管理器
- `MigrationManager` 注册所有迁移器，按版本链执行

---

### 3.5 异步存储支持
- 所有存储操作提供 `Task` 版本，避免阻塞主线程
- 对于 Unity，可选 `UniTask` 或 `Coroutine` 适配层
- 异步实现需保证数据一致性（写入时锁定文件，防止并发写入）

---

### 3.6 高层封装 API（PersistenceManager）
- 提供 `Save<T>(T data)` / `Load<T>()` / `Delete<T>()`
- 自动完成：
    - Key 生成
    - 数据包装（版本、hash、加密）
    - 选择序列化策略与存储介质
    - 异常处理与默认值回退
- 提供配置对象 `PersistenceConfig`：
    - 默认存储路径/文件名规则
    - 默认序列化器
    - 默认加密器/校验器
    - 是否启用异步写入
    - 是否使用压缩（如 GZip）

---

## 4. 数据版本兼容与迁移详细说明

### 4.1 版本字段
- 每个存储数据类型对应一个版本号 **CurrentVersion**
- `DataWrapper` 保存数据本体 + 版本信息
- 版本号和数据强绑定，避免不同数据结构混淆

### 4.2 迁移器
- 每个迁移器处理 **从一个特定旧版本 → 下一版本** 的升级
- 如果差距超过 1 版本，会自动链式调用中间迁移器

### 4.3 加载与迁移流程
```
[开始]
 ↓
存储介质读取原始数据
 ↓
解密（IEncryptor）
 ↓
校验（IValidator）
 ↓
反序列化为 DataWrapper
 ↓
检查版本号
 ↓
若版本 < 当前：
   依次执行迁移器
 ↓
序列化为最终对象
 ↓
返回业务层
[结束]
```

---

## 5. 配置与扩展

### 5.1 开发者可扩展点
- 自定义 `IPersistenceProvider`
- 自定义 `IDataSerializer`（如 Protobuf）
- 自定义 `IEncryptor`（如 XOR、RSA 混合 AES）
- 自定义 `IValidator`
- 注册 `IDataMigrator` 进行数据过渡
- 配置 **存储位置**（Application.persistentDataPath、云端、内存）

### 5.2 默认实现
- 存储介质：
    - 本地文件（支持二进制 / 文本）
- 序列化：
    - Json（UTF-8）
- 数据安全：
    - 可选 AES 加密
    - SHA256 校验
- 迁移：
    - 版本号变更时自动调用已注册迁移器

---

## 6. 异常情况处理

- **文件不存在** → 返回默认值
- **反序列化失败**：
    - 尝试从备份文件恢复
    - 如果无备份 → 返回默认值
- **加密解密失败** → 视为数据损坏，触发恢复策略
- **迁移失败** → 记录日志，回退到安全状态

---

## 7. 性能与优化

- 异步读写避免阻塞主线程
- 支持内存缓存常用数据，减少 I/O
- 支持数据压缩，减少存储体积
- 小数据类型可以合并存储，降低文件系统开销
