# xFrame 序列化模块

## 概述

序列化模块提供统一的序列化和反序列化接口，支持多种序列化格式（如JSON、MessagePack等）。模块设计遵循以下原则：

- **统一接口**：通过 `ISerializer` 接口定义标准的序列化操作
- **可扩展**：支持注册自定义序列化器
- **可配置**：支持动态切换默认序列化器
- **依赖注入**：与VContainer集成，支持依赖注入
- **事件驱动**：序列化器的注册、注销、切换都会触发相应事件

## 核心组件

### 1. ISerializer 接口

定义序列化器的标准操作：

```csharp
public interface ISerializer
{
    // 序列化器名称
    string Name { get; }
    
    // 序列化为字节数组
    byte[] Serialize<T>(T obj);
    
    // 序列化为字符串
    string SerializeToString<T>(T obj);
    
    // 从字节数组反序列化
    T Deserialize<T>(byte[] data);
    
    // 从字符串反序列化
    T DeserializeFromString<T>(string data);
    
    // 使用Type参数反序列化
    object Deserialize(Type type, byte[] data);
    object DeserializeFromString(Type type, string data);
}
```

### 2. ISerializerManager 接口

序列化管理器，提供统一的序列化服务入口：

```csharp
public interface ISerializerManager
{
    // 默认序列化器
    ISerializer DefaultSerializer { get; }
    
    // 注册/注销序列化器
    void RegisterSerializer(string name, ISerializer serializer);
    bool UnregisterSerializer(string name);
    
    // 获取/设置序列化器
    ISerializer GetSerializer(string name);
    void SetDefaultSerializer(string name);
    
    // 使用默认序列化器
    byte[] Serialize<T>(T obj);
    string SerializeToString<T>(T obj);
    T Deserialize<T>(byte[] data);
    T DeserializeFromString<T>(string data);
    
    // 使用指定序列化器
    byte[] Serialize<T>(string serializerName, T obj);
    string SerializeToString<T>(string serializerName, T obj);
    T Deserialize<T>(string serializerName, byte[] data);
    T DeserializeFromString<T>(string serializerName, string data);
}
```

### 3. JsonSerializer

基于Unity JsonUtility的默认JSON序列化器实现：

```csharp
// 创建普通JSON序列化器
var serializer = new JsonSerializer();

// 创建格式化输出的JSON序列化器
var prettySerializer = new JsonSerializer(prettyPrint: true);
```

## 快速开始

### 1. 通过依赖注入使用

推荐的使用方式，通过VContainer注入 `ISerializerManager`：

```csharp
using VContainer;
using xFrame.Runtime.Serialization;

public class GameSaveService
{
    private readonly ISerializerManager _serializer;
    
    // 通过构造函数注入
    [Inject]
    public GameSaveService(ISerializerManager serializer)
    {
        _serializer = serializer;
    }
    
    public void SaveGame(GameData data)
    {
        // 序列化为JSON字符串
        string json = _serializer.SerializeToString(data);
        
        // 或序列化为字节数组
        byte[] bytes = _serializer.Serialize(data);
        
        // 保存到文件...
    }
    
    public GameData LoadGame(string json)
    {
        // 从JSON字符串反序列化
        return _serializer.DeserializeFromString<GameData>(json);
    }
}
```

### 2. 直接创建实例使用

在不使用依赖注入的场景下，可以直接创建实例：

```csharp
// 创建序列化管理器（自动注册默认的JSON序列化器）
var serializerManager = new SerializerManager();

// 序列化
var data = new PlayerData { Name = "Hero", Level = 10 };
string json = serializerManager.SerializeToString(data);

// 反序列化
var restored = serializerManager.DeserializeFromString<PlayerData>(json);
```

### 3. 使用指定的序列化器

```csharp
// 注册自定义序列化器
var prettySerializer = new JsonSerializer(prettyPrint: true);
serializerManager.RegisterSerializer("PrettyJson", prettySerializer);

// 使用指定的序列化器（不改变默认）
string prettyJson = serializerManager.SerializeToString("PrettyJson", data);

// 或者切换默认序列化器
serializerManager.SetDefaultSerializer("PrettyJson");
string json = serializerManager.SerializeToString(data); // 现在使用PrettyJson
```

## 数据类定义

### 基本要求

使用Unity JsonUtility序列化时，数据类需要满足以下条件：

1. 类必须标记 `[Serializable]` 特性
2. 字段必须是 `public` 或标记 `[SerializeField]`
3. 支持的类型：基本类型、字符串、数组、List、嵌套的可序列化类

### 示例

```csharp
using System;
using UnityEngine;

[Serializable]
public class PlayerData
{
    public string PlayerName;
    public int Level;
    public float Experience;
    public bool IsVIP;
    
    // 嵌套对象
    public PlayerStats Stats;
    
    // 数组
    public string[] Achievements;
    
    // 私有字段需要SerializeField
    [SerializeField]
    private int _secretValue;
}

[Serializable]
public class PlayerStats
{
    public int Health;
    public int MaxHealth;
    public int Attack;
    public int Defense;
}
```

## 事件系统

序列化模块与xFrame事件总线集成，提供以下事件：

### SerializerRegisteredEvent

当新的序列化器被注册时触发：

```csharp
xFrameEventBus.SubscribeTo<SerializerRegisteredEvent>((ref SerializerRegisteredEvent e) =>
{
    Debug.Log($"序列化器已注册: {e.SerializerName}");
    // e.Serializer - 序列化器实例
});
```

### SerializerUnregisteredEvent

当序列化器被注销时触发：

```csharp
xFrameEventBus.SubscribeTo<SerializerUnregisteredEvent>((ref SerializerUnregisteredEvent e) =>
{
    Debug.Log($"序列化器已注销: {e.SerializerName}");
});
```

### DefaultSerializerChangedEvent

当默认序列化器被更改时触发：

```csharp
xFrameEventBus.SubscribeTo<DefaultSerializerChangedEvent>((ref DefaultSerializerChangedEvent e) =>
{
    Debug.Log($"默认序列化器已更改: {e.PreviousSerializerName} -> {e.NewSerializerName}");
});
```

## 扩展自定义序列化器

### 实现ISerializer接口

```csharp
public class MessagePackSerializer : ISerializer
{
    public const string SerializerName = "MessagePack";
    
    public string Name => SerializerName;
    
    public byte[] Serialize<T>(T obj)
    {
        // 使用MessagePack库序列化
        return MessagePackSerializer.Serialize(obj);
    }
    
    public string SerializeToString<T>(T obj)
    {
        // MessagePack是二进制格式，转为Base64
        var bytes = Serialize(obj);
        return Convert.ToBase64String(bytes);
    }
    
    public T Deserialize<T>(byte[] data)
    {
        return MessagePackSerializer.Deserialize<T>(data);
    }
    
    public T DeserializeFromString<T>(string data)
    {
        var bytes = Convert.FromBase64String(data);
        return Deserialize<T>(bytes);
    }
    
    public object Deserialize(Type type, byte[] data)
    {
        return MessagePackSerializer.Deserialize(type, data);
    }
    
    public object DeserializeFromString(Type type, string data)
    {
        var bytes = Convert.FromBase64String(data);
        return Deserialize(type, bytes);
    }
}
```

### 注册自定义序列化器

```csharp
// 方式1：通过SerializerManager注册
var manager = container.Resolve<ISerializerManager>();
manager.RegisterSerializer(MessagePackSerializer.SerializerName, new MessagePackSerializer());

// 方式2：通过VContainer扩展方法注册
public class GameLifetimeScope : LifetimeScope
{
    protected override void Configure(IContainerBuilder builder)
    {
        // 注册序列化模块
        builder.RegisterSerializationModule();
        
        // 注册自定义序列化器
        builder.RegisterSerializer<MessagePackSerializer>();
    }
}
```

## VContainer集成

### 自动注册

序列化模块已在 `xFrameLifetimeScope` 中自动注册：

```csharp
protected override void Configure(IContainerBuilder builder)
{
    // ... 其他模块注册
    RegisterSerializationModule(builder);
}

private void RegisterSerializationModule(IContainerBuilder builder)
{
    builder.RegisterSerializationModule();
}
```

### 手动注册

如果需要在自定义的LifetimeScope中注册：

```csharp
using VContainer;
using xFrame.Runtime.Serialization;

public class MyLifetimeScope : LifetimeScope
{
    protected override void Configure(IContainerBuilder builder)
    {
        // 使用扩展方法注册
        builder.RegisterSerializationModule();
    }
}
```

### 注入方式

```csharp
// 构造函数注入
public class MyService
{
    private readonly ISerializerManager _serializer;
    
    public MyService(ISerializerManager serializer)
    {
        _serializer = serializer;
    }
}

// 字段注入
public class MyMonoBehaviour : MonoBehaviour
{
    [Inject]
    private ISerializerManager _serializer;
}

// 方法注入
public class MyClass
{
    private ISerializerManager _serializer;
    
    [Inject]
    public void Construct(ISerializerManager serializer)
    {
        _serializer = serializer;
    }
}
```

## 最佳实践

### 1. 使用依赖注入

优先使用依赖注入获取 `ISerializerManager`，而不是直接创建实例，这样便于测试和替换实现。

### 2. 数据类设计

- 保持数据类简单，只包含数据字段
- 避免在数据类中包含方法逻辑
- 使用基本类型和简单的嵌套结构
- 避免循环引用

### 3. 错误处理

```csharp
try
{
    var data = _serializer.DeserializeFromString<PlayerData>(json);
}
catch (Exception ex)
{
    Debug.LogError($"反序列化失败: {ex.Message}");
    // 使用默认值或进行错误恢复
}
```

### 4. 版本兼容

当数据结构发生变化时，考虑版本兼容性：

```csharp
[Serializable]
public class PlayerData
{
    public int Version = 2; // 数据版本号
    public string PlayerName;
    public int Level;
    
    // 新增字段使用默认值
    public float NewField = 0f;
}
```

### 5. 性能考虑

- 对于频繁序列化的场景，考虑使用二进制格式（如MessagePack）
- 避免序列化大型对象图
- 考虑使用对象池复用序列化缓冲区

## 常见问题

### Q: 为什么某些字段没有被序列化？

A: 检查以下几点：
1. 类是否标记了 `[Serializable]`
2. 字段是否是 `public` 或标记了 `[SerializeField]`
3. 字段类型是否被Unity JsonUtility支持

### Q: 如何序列化Dictionary？

A: Unity JsonUtility不直接支持Dictionary。可以：
1. 转换为两个数组（keys和values）
2. 使用其他序列化库（如Newtonsoft.Json）
3. 创建自定义的可序列化包装类

### Q: 如何处理多态类型？

A: Unity JsonUtility不支持多态。可以：
1. 使用类型标识字段手动处理
2. 使用支持多态的序列化库

## API参考

### ISerializer

| 方法 | 说明 |
|------|------|
| `Serialize<T>(T obj)` | 序列化为字节数组 |
| `SerializeToString<T>(T obj)` | 序列化为字符串 |
| `Deserialize<T>(byte[] data)` | 从字节数组反序列化 |
| `DeserializeFromString<T>(string data)` | 从字符串反序列化 |

### ISerializerManager

| 方法 | 说明 |
|------|------|
| `RegisterSerializer(name, serializer)` | 注册序列化器 |
| `UnregisterSerializer(name)` | 注销序列化器 |
| `GetSerializer(name)` | 获取指定序列化器 |
| `SetDefaultSerializer(name)` | 设置默认序列化器 |

### 事件

| 事件 | 说明 |
|------|------|
| `SerializerRegisteredEvent` | 序列化器注册事件 |
| `SerializerUnregisteredEvent` | 序列化器注销事件 |
| `DefaultSerializerChangedEvent` | 默认序列化器变更事件 |
